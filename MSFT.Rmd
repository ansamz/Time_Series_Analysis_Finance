---
title: "The Impact of News Sentiment on MSFT"
author: "Ansam Zedan, Daniel Wullschleger"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r include=FALSE}
if (!require("vars")) install.packages("vars", dependencies=TRUE)
if (!require("tseries")) install.packages("tseries", dependencies=TRUE)
if (!require("quantmod")) install.packages("quantmod", dependencies=TRUE)
if (!require("PerformanceAnalytics")) install.packages("PerformanceAnalytics", dependencies=TRUE)
if (!require("forecast")) install.packages("forecast", dependencies=TRUE)
if (!require("rugarch")) install.packages("rugarch", dependencies=TRUE)
if (!require("tinytex")) install.packages("tinytex", dependencies=TRUE)
if (!require("zoo")) install.packages("zoo", dependencies=TRUE)
if (!require("ggplot2")) install.packages("ggplot2", dependencies=TRUE)

library(PerformanceAnalytics)
library(forecast)
library(rugarch)
library(vars)
library(tseries)
library(quantmod)
library(tinytex)
library(zoo)
library(ggpl)
```
# Insert introduction here

First we get the recent MSFT price data from the beginning of 2022 up to today via yahoo API and plot it so that we can inspect if the time series already behaves stationary

```{r echo=FALSE, include=TRUE}
MSFT <- getSymbols.yahoo("MSFT", from="2022-01-01", to="2023-12-01", periodicity = "daily", auto.assign=FALSE)[,6]

#ChatGPT <- read.csv("ChatGPT.csv")
plot(MSFT)
```
We see a clear trend, which is an indicator for non-stationarity, so we do an Augmented Dickey-Fuller (ADF) Test to see whether the data is already stationary.
 
```{r echo=FALSE, include=TRUE}
adf.test(MSFT) 
```

We see that based on the p-value of the ADF Test, that the price data itself is non-stationary.
So we a apply a log-transform with subsequent differencing to calculate continuous returns on MSFT. These should behave stationary.

In the same step, we divide the dataset into a Train/Test Split, whereas November 2023 will serve as a test set for later predicitions

```{r echo=FALSE, include=TRUE}
MSFT_returns <- na.omit(diff(log(MSFT)))
colnames(MSFT_returns)<-"MSFT_Returns"

MSFT_returns_test <- window(MSFT_returns, start="2023-10-01")
MSFT_returns_train <- window(MSFT_returns, end="2023-09-30")

plot(MSFT_returns)
adf.test(MSFT_returns)
```
Now, that we deal with stationary data we can begin with our analysis. 

First we include the News Time Series to then create a Vector Autoregression model as we want to find out, whether News are a causal driver for MSFT price returns.

We then do a coefficient test, to get more information on the statistical significance of the coefficients of our VAR Model.

```{r echo=FALSE, include=TRUE}
#MSFT_VAR <- VAR(cbind(MSFT_returns_train, ChatGPT), ic="AIC", lag.max = 24)
#coeftest(MSFT_VAR)
```

As not all coeffcients are signifcant, we may do a causality test. This way, we can find out, if  News are in fact a causal driver for MSFT prices



```{r echo=FALSE, include=TRUE}
#causality(MSFT_VAR, cause="ChatGPT")["Granger"] 
#causality(VAR_est, cause="Inflation_CH")["Granger"] 

```

Lastly, it would be interesting to find out how  News actually influence the MSFT price returns. So that we may estimate long  such news do have effect on the price.

For this we simulate shocks to the system


```{r echo=FALSE, include=TRUE}
#plot(irf(VAR_est, impulse="ChatGPT", response="MSFT_returns"))

```


As a benchmark for our VAR Model that features News sentiment as a predictor, we use an ARMA model that is purely based on the price returns of MSFT. This way, we can forecast values of November 2023 and compare the predictions to the actual MSFT price returns to measure its accuracy.

MSFT_prediction <- predict

```{r echo=FALSE, include=TRUE}
MSFT_benchmark_ARMA <- auto.arima(MSFT_returns_train)
MSFT_benchmark_pred <- forecast(MSFT_benchmark_ARMA, level=95, h=43)

plot(MSFT_benchmark_pred)

```













GARCH Model:

For our GARCH model we calculate a 30-day rolling volatility

```{r echo=FALSE, include=TRUE}
chart.RollingPerformance(R = MSFT_returns, width = 30,
                         FUN = "sd.annualized", scale = 252, main = "30-day rolling volatility")

```
To setup a GARCH Model for our MSFT analysis we have to specify the orders of an ARMA model as well as a GARCH Model. 

From class we learned, that in Finance it is common to stick to a GARCH(1,1) model, so we just need to estimate the ARMA model orders. For this, we let auto.arima find the best fitting orders


```{r echo=FALSE, include=TRUE}
auto.arima(MSFT_returns)
```

We see that auto.arima has found that the auto-regressive (AR) part of the ARMA model has an order of 2 present as the coefficients ar1 and ar2 were estimated. The Absence of ma coefficients suggests that the Moving Average (MA) part has an order of 0.

Now we can specify our GARCH model and fit it to our data.

```{r echo=TRUE, include=TRUE}
MSFT_garch_spec <- ugarchspec(mean.model = list(armaOrder = c(2,0), include.mean = TRUE),
                        variance.model = list(garchOrder = c(1,1), model = "sGARCH"))

MSFT_garch_fit <- ugarchfit(data = MSFT_returns, spec = MSFT_garch_spec)
```

Now we can use the sigma method to extract the estimated GARCH volatilities, so that we can plot them on a chart

```{r echo=FALSE, include=TRUE}
MSFT_volatility <- sigma(MSFT_garch_fit)

par(mfrow=c(2,1)) 
plot(MSFT_volatility, main="MSFT GARCH volatility")
plot(abs(MSFT_returns), main="Realized volatility")
```

As a last step, we may forecast the returns and volatility values.
Here, ARMA will estimate the returns, while GARCH estimates the volatilities

```{r echo=FALSE, include=TRUE}
par(mfrow=c(1,1))
MSFT_volatility_forecast <- ugarchforecast(fitORspec = MSFT_garch_fit, n.ahead = 5)
plot(MSFT_volatility_forecast, which=1)
plot(MSFT_volatility_forecast, which=3)
```

```{r echo=FALSE, include=TRUE}
auto.arima(MSFT_returns)
```

```{r echo=FALSE, include=TRUE}
auto.arima(MSFT_returns)
```

```{r echo=FALSE, include=TRUE}
auto.arima(MSFT_returns)
```

